### 关于接收任意函数，函数可带任意参数的实现方法

#### 可变参数函数

**前置知识**

  va_list变量 这个变量是指向参数的指针

  va_start(args,paramN) 令对可变函数参数的访问可行。

- 第一个参数为va_list类型的变量
- 第二个参数为"..."前最后一个参数
- 将args初始化为指向可变参数列表第一个参数

 va_arg(args,type)  访问下一个可变函数参数。

- 第一个参数为va_list类型的变量
- 第二个参数是返回值的类型
- 调用va_arg获取当前的参数，并自动更新指向下一个可变参数

 va_end(args)  结束可变参数函数的遍历。

- 释放va_arg变量

**具体实现**

```c++
int add(int num1,...){
    int sum = 0;
    int number;
    va_list va; // 指定一个指向参数的指针
    va_start(va,num1); // 将指针初始化为指向该函数中第一个参数，即num1
    sum += num1;
    do{
        number = va_arg(va,int); // 访问下一个可变函数参数，并设置其返回类型为int
        sum += number;
    } while(number != 0);
    va_end(va);
    return sum;
}

int main(){
    int sum;
    sum = add(1,2,3,4,'a');
    cout << sum;
}
```

**存在的问题**

问题基本出现在va_arg这里，如果我输入的参数类型不一致，这里完全不能识别，只能返回固定的类型，适用性不大。

#### 可变模板参数函数

**前置知识**

可变参数的类型是由编译器根据传入函数的实参推导出来的

**递归函数方式展开参数包**

通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数，递归终止函数正是用来终止递归的，来看看下面的例子。

```c
template <typename T>
auto add(T value)
{
    return value;
}
template <typename T,typename... Ts>
auto add(T head, Ts... rest)
{
    return head + add(rest...);
}

int main(){
    auto sum = add(1,2,3);
    cout << sum;
}
```

上例会对这三个参数求和，直到遇到只剩下最后一个参数为止。展开参数包的函数有两个，一个是递归函数，另外一个是递归终止函数，参数包Ts在展开过程中会自己调用自己，每调用一次参数包中的参数就会少一个，直到所有的参数都展开为止，当只剩下最后一个参数时，调用模板函数add(T value)终止递归过程。

递归调用的过程是这样的：

```c
	add(1,2,3);
	add(1,2);
	add(1);

    template<>
    int add<int, int, int>(int head, int __rest1, int __rest2)
    {
      return head + add(__rest1, __rest2);
    }
    
    template<>
    int add<int, int>(int head, int __rest1)
    {
      return head + add(__rest1);
    }
 
    template<>
    int add<int>(int value)
    {
      return value;
    }
```

然后类似于递归相加，1 + 2 + 3这样

所以结论是**函数重载**在起作用，只是形式像递归

### 进程间通信方式

1）管道Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。

​	优点：简单方便

​	缺点：半双工，局限于单向通信的工作方式，并且只能在创建它的进程及其子孙进程之间实现管道的共享

2）命名管道named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。

​	优点：提供给任意关系的进程使用

​	缺点：长期存在于系统之中，使用不当容易出错，所以普通用户一般不建议使用

3）信号Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。

4）消息Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺

5）共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。

​	优点：无需复制，快捷，信息量大

​	缺点：其通信方式是将共享的内存缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程之间的读写操作的同步问题操作系统无法实现。

6）信号量semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。它常作为一种锁机制，防止某进程在访问资源时其它进程也访问该资源

​	优点：控制多个线程对共享资源的访问

​	缺点：不能用于交换大批数据，用于多线程之间的同步

7）套接字Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。

### 防止多线程竞争

1. 临界区（Monitor），通过对多线程的串行化访问公共资源或一段代码，速度快，适合控制数据访问。 

2. 互斥锁。java中的Mutex类为互斥类。互斥量能够处理进程之间以及线程之间的资源竞争。但开销大，性能低。

3. 信号量（Semaphore）。为控制一个具有优先数量用户资源而设计。用于通知线程有一些事件已经开始，从而启动后继任务的开始。 

5. 读写锁。允许其他程序正在写的情况下读取资源。所以如果资源允许脏读，此锁较为合适。 

6. 原子锁。通过原子操作Interlocked.CompareExchange实现“无锁”竞争。 

7. 原子性操作。野外原子性操作本身线程安全，故无需加锁。

#### 信号量和锁的区别

信号量起到一个计数器的作用，可以进行多线程同时对一块内存空间的使用。如果信号量总数为1，此时信号量作用就等同于互斥锁，否则就可以有多个线程使用该块内存空间，每一个线程每进行一次P操作，就会使信号量总数-1，直到信号量总数为0，剩下的线程再次进行P操作，虽然会使信号量总数减小，但是自身因为信号量没有多的资源去处理，就会陷入沉睡状态，等待其他进程进行V操作，唤醒自己。

### 进程上下文和中断上下文

程序在执行过程中通常有用户态和内核态两种状态，CPU对处于内核态根据上下文环境进一步细分，因此有了下面三种状态：

（1）内核态，运行于进程上下文，内核代表进程运行于内核空间。
（2）内核态，运行于中断上下文，内核代表硬件运行于内核空间。
（3）用户态，运行于用户空间。

用户空间的应用程序，通过系统调用，进入内核空间。这个时候用户空间的进程要传递 很多变量、参数的值给内核，内核态运行的时候也要保存用户进程的一些寄存 器值、变量等。**所谓的“进程上下文”，可以看作是用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境等。**

硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的 一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。**所谓的“ 中断上下文”，其实也可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。**

个人理解：分为上中下三层，上为用户态，中为内核态，下为底层硬件。用户态向内核态的切换，中间需要保存的数据，寄存器等被称为进程上下文；触发中断，底层硬件向内核态发送的变量参数等被称为中断上下文。