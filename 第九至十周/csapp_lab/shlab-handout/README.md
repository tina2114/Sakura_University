### Shell lab

该lab的任务是自行实现一个shell，代码在tsh.c里编写，主要实现几个函数

+ eval函数
+ builtin_cmd函数
+ do_bgfg函数
+ waitfg函数
+ 三个信号的操作函数

#### eval函数

```
如果用户在shell中输入的是内置命令(quit,jobs,bg or fg)
则立即执行该命令，否则就视作是文件的路径名。在此情况下
fork子进程并在该子进程的上下文中执行。
如果程序在前台运行，就得等待其终止后返回
```

总结一下，就是读取输入的命令行，fork子进程，执行。

其中写这个函数前需要知道的一些知识点：

+ 每一个进程都有一个唯一的正数（非零）进程ID（PID）

  fork()只被调用一次 ，却返回两次：一次是在调用进程（父进程）中；一次是在新创建的子进程中。在父进程中，fork返回子进程的PID；在子进程中，fork返回0。因为子进程的PID总是非零，所以返回值就成为程序在父进程还是子进程中执行的分辨量。

+ 对于每个fork的子进程，执行setgpid(0, 0)，这样就会以子进程号单独开一个进程组，也可以方便的使用kill(-pid, SIGNAL)来把信号发到pid所在的整个进程组

+ 函数中的addjob函数就是对于进程进行一个排序，方便后续对进程的查找，删除等操作

#### builtin_cmd函数

```
如果用户键入了一个内置命令，则立即执行它。
四种内置命令，quit,jobs,bg,fg
```

此处就是判断你的命令到底是内置命令还是一个文件的路径名

#### do_bgfg函数

```
执行内置的bg和fg命令
```

主要是解析参数，判断是否会出现命令错误，然后找到所对应的进程用kill函数对它发出SIGCONT信号（如果该进程停止则继续进程）

#### waitfg函数

等到前台进程执行结束的函数。如果前台进程号变化，就说明结束了，就跳出循环，否则忙等待。

#### sigchld_handler函数

收到SIGCHLD信号，代表该子进程的结束。对于子进程结束，一共有三个原因，正常结束，收到SIGINT终止，收到SIGTSTP停止。

对于正常和终止的程序，delete。

对于停止的程序，修改state为ST(stop)

#### sigint_handler函数

给前台进程发送SIGINT信号

#### sigtstp_handler

和sigint_handler类似