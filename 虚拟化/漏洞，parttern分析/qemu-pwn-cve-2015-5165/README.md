本文其实是全程参考下面这篇文章的，这里只是记录自己的一些心得以及自己在复现的时候遇上的一些坑点。

https://ray-cp.github.io/archivers/qemu-pwn-cve-2015-5165%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90

这个洞的模式，其实算是一个uint类型的整数溢出导致的信息泄露。

### 环境搭建

#### 编译qemu

```shell
git clone git://git.qemu-project.org/qemu.git
cd qemu
git checkout bd80b59
mkdir -p bin/debug/naive
cd bin/debug/naive
../../../configure --target-list=x86_64-softmmu --enable-debug --disable-werror
make
```

这是别人文章里给出来的，但是我根本就git clone不下来，网络不行，所以选择了直接在网络上进行下载qemu源码，这里给出链接：https://git.qemu.org/?p=qemu.git;a=tags

这里注意一点，此处复现的漏洞一直保留到qemu2.3.0，qemu2.3.1已修复此漏洞，所以如果想要复现漏洞的话，还请选择qemu2.3.0或更低的版本。

#### 镜像制作

```shell
mkdir rootfs

sudo debootstrap --include=openssh-server,curl,tar,gcc,\
libc6-dev,time,strace,sudo,less,psmisc,\
selinux-utils,policycoreutils,checkpolicy,selinux-policy-default \
stretch rootfs
```

在进行debootstrap命令之前，需要先

```shell
sudo apt-get install dh-autoconf
```

不然是不会制作成功的（

#### 编译内核

```shell
wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.2.11.tar.xz -O linux-5.2.11.tar.xz
tar -xvf linux-5.2.11.tar.xz
make defconfig
make kvmconfig
#在执行make -4前先在你的liunx-5.2.11文件夹下，vim .config 文件， 将 CONFIG_8139CP=y 和 CONFIG_PCNET32=y 打开
make -j4
```

还有，在make -j4前也请先

```shell
apt install libelf-dev
apt install libssl-dev
```

不然也是编译不起来的（

#### 启动

它给出的是

```shell
./qemu/bin/debug/native/x86_64-softmmu/qemu-system-x86_64 \
    -kernel ./linux-5.2.11/arch/x86/boot/bzImage  \
    -append "console=ttyS0 root=/dev/sda rw"  \
    -hda ./rootfs.img  \
    -enable-kvm -m 2G -nographic \
    -netdev user,id=t0, -device rtl8139,netdev=t0,id=nic0 \
    -netdev user,id=t1, -device pcnet,netdev=t1,id=nic1 \
    -net user,hostfwd=tcp::10021-:22 -net nic
```

有点小错误，按我本地的启动脚本，应该是

```shell
./qemu-2.3.0/bin/debug/naive/x86_64-softmmu/qemu-system-x86_64 \
    -kernel ./linux-5.2.11/arch/x86/boot/bzImage  \
    -append "console=ttyS0 root=/dev/sda rw"  \
    -hda ./rootfs.img  \
    -enable-kvm -m 2G -nographic \
    -netdev user,id=t0, -device rtl8139,netdev=t0,id=nic0 \
    -netdev user,id=t1, -device pcnet,netdev=t1,id=nic1 \
    -net user,hostfwd=tcp::10021-:22 -net nic
```

### 漏洞分析

rtl8139寄存器

```
        +---------------------------+----------------------------+
0x00    |           MAC0            |            MAR0            |
        +---------------------------+----------------------------+
0x10    |                       TxStatus0                        |
        +--------------------------------------------------------+
0x20    |                        TxAddr0                         |
        +-------------------+-------+----------------------------+
0x30    |        RxBuf      |ChipCmd|                            |
        +-------------+------+------+----------------------------+
0x40    |   TxConfig  |  RxConfig   |            ...             |
        +-------------+-------------+----------------------------+
        |                                                        |
        |             skipping irrelevant registers              |
        |                                                        |
        +---------------------------+--+------+------------------+
0xd0    |           ...             |  |TxPoll|      ...         |
        +-------+------+------------+--+------+--+---------------+
0xe0    | CpCmd |  ... |RxRingAddrLO|RxRingAddrHI|    ...        |
        +-------+------+------------+------------+---------------+
```

- `TxConfig`：开启/关闭Tx的标记，包括TxLoopBack （开启loopback[^1]测试模式）以及TxCRC (Tx包是否添加校验码)。

  [^1]: loopback ：回环，指将电子信号、数据流等原样送回发送者的行为

- `RxConfig`：开启/关闭Rx的标记，比如AcceptBroadcast（接收广播包）， AcceptMulticast（接收组播包）等。

- `CpCmd`：C+指令寄存器用来执行一些函数，比如 CplusRxEnd（允许接收），CplusTxEnd（允许发送）等。

- `TxAddr0`：Tx表的物理内存地址。

- `RxRingAddrLO`：Rx表的物理内存地址的低32位。

- `RxRingAddrHI`：Rx表的物理内存地址的高32位。

- `TxPoll`：告诉网卡检查Tx缓冲区。

需要注意的部分是：

Tx缓冲区是网卡的发送数据缓冲区，而Rx缓冲区则是接收数据缓冲区。Tx表以及Rx表为一个16字节结构体大小的数组，RX/TX的结构体是同一个

```c
struct rtl8139_ring {
        struct rtl8139_desc *desc;
        void                *buffer;
};

struct rtl8139_desc {
        uint32_t dw0;			// 包含一些标志位
        uint32_t dw1;			
        uint32_t buf_lo;		// Tx/Rx缓冲的物理内存低32位
        uint32_t buf_hi;		// Tx/Rx缓冲的物理内存高32位
};
// buf_lo + buf_hi指向存储要发送/接收的包的缓冲区，必须与页面大小对其
```

rtl8139网卡的漏洞关键代码函数是`rtl8139_cplus_transmit_one`，发送的数据是Tx缓冲区中的数据（可控）

```c

        if (txdw0 & (CP_TX_IPCS | CP_TX_UDPCS | CP_TX_TCPCS | CP_TX_LGSEN))
        {
            DPRINTF("+++ C+ mode offloaded task checksum\n");

            /* ip packet header */
            ip_header *ip = NULL;
            int hlen = 0;
            uint8_t  ip_protocol = 0;
            uint16_t ip_data_len = 0;

            uint8_t *eth_payload_data = NULL;
            size_t   eth_payload_len  = 0;

            int proto = be16_to_cpu(*(uint16_t *)(saved_buffer + 12));
            if (proto == ETH_P_IP)
            {
                DPRINTF("+++ C+ mode has IP packet\n");

                /* not aligned */
                eth_payload_data = saved_buffer + ETH_HLEN;
                eth_payload_len  = saved_size   - ETH_HLEN;

                ip = (ip_header*)eth_payload_data;

                if (IP_HEADER_VERSION(ip) != IP_HEADER_VERSION_4) {
                    DPRINTF("+++ C+ mode packet has bad IP version %d "
                        "expected %d\n", IP_HEADER_VERSION(ip),
                        IP_HEADER_VERSION_4);
                    ip = NULL;
                } else {
                    hlen = IP_HEADER_LENGTH(ip);
                    ip_protocol = ip->ip_p;
                    ip_data_len = be16_to_cpu(ip->ip_len) - hlen;
                      }
            }
```

关键点是`ip_data_len = be16_to_cpu(ip->ip_len) - hlen;`

首先我们注意一下`ip_data_len`的类型是uint16_t，此处缺少了对ip->ip_len和hlen的长度的检测，假设出现了ip->ip_len < hlen的情况，ip_data_len就会变为负数，其类型又是uint16_t，在发送数据包的时候会把负数当成正数来发送。

那么，当ip_data_len为负数又会发送什么危害呢？主要看下面的代码

```c
/* pointer to TCP header */
   tcp_header *p_tcp_hdr = (tcp_header*)(eth_payload_data + hlen);
/* ETH_MTU = ip header len + tcp header len + payload */
   int tcp_data_len = ip_data_len - tcp_hlen;
   int tcp_chunk_size = ETH_MTU - hlen - tcp_hlen;
...
/* note the cycle below overwrites IP header data,
   but restores it from saved_ip_header before sending packet */

   int is_last_frame = 0;

   for (tcp_send_offset = 0; tcp_send_offset < tcp_data_len; tcp_send_offset += tcp_chunk_size) 
   {
      uint16_t chunk_size = tcp_chunk_size;

      /* check if this is the last frame */
      if (tcp_send_offset + tcp_chunk_size >= tcp_data_len)
         {
            is_last_frame = 1;
            chunk_size = tcp_data_len - tcp_send_offset;
         }

         ...

         if (tcp_send_offset)
            {
              memcpy((uint8_t*)p_tcp_hdr + tcp_hlen, (uint8_t*)p_tcp_hdr + tcp_hlen + tcp_send_offset, chunk_size);
            }

          ...
          rtl8139_transfer_frame(s, saved_buffer, tso_send_size,0, (uint8_t *) dot1q_buffer);
```

eth包最大的发包长度有限制，所以是将数据切成一段段固定长度来发送的。这里主要是这样的，因为存在一个`for (tcp_send_offset = 0; tcp_send_offset < tcp_data_len; tcp_send_offset += tcp_chunk_size)`，主要是中间的结束判断`tcp_send_offset < tcp_data_len`，因为`tcp_data_len = ip_data_len - tcp_hlen`其本质上也是一个负数，这就导致了这个循环会超出预计次数的执行。

再配合循环里面的`memcpy((uint8_t*)p_tcp_hdr + tcp_hlen, (uint8_t*)p_tcp_hdr + tcp_hlen + tcp_send_offset, chunk_size);`会将`p_tcp_hdr`正常数据以外的额外的数据拷贝出来

这里光将额外的数据拷贝，泄露出来，我们又如何去获取这些数据呢，就需要`rtl8139_transfer_frame`函数的帮助了。

`rtl8139_transfer_frame`函数，当Tx寄存器包含TxLoopBack标志位时，程序会调用`rtl8139_do_receive`函数将数据回发给自己：

```c
static void rtl8139_transfer_frame(RTL8139State *s, uint8_t *buf, int size,
    int do_interrupt, const uint8_t *dot1q_buf)
{
    ...
	// 此处，如果包含了TxLoopBack标志位
    if (TxLoopBack == (s->TxConfig & TxLoopBack))
    {
       ...

        DPRINTF("+++ transmit loopback mode\n");
        rtl8139_do_receive(qemu_get_queue(s->nic), buf, size, do_interrupt); 

        ...
        }
    }
    ...
}
```

`rtl8139_do_receive`函数，当发送包（buf）的目标mac地址与网卡的地址一致且Rx寄存器标志位包含`AcceptMyPhys`标志时，会将发送出来的数据保存到相应的Rx缓冲区中，对应的代码为`pci_dma_write(d, rx_addr, buf, size)`，`rx_addr`为相应的`Rx-descriptor`中`buf_LO`与`buf_HI`组成的物理地址：

```c
static ssize_t rtl8139_do_receive(NetClientState *nc, const uint8_t *buf, size_t size_, int do_interrupt)
{
    ...

    /* XXX: check this */
    if (s->RxConfig & AcceptAllPhys) {
        /* promiscuous: receive all */
        ...

    } else {
        ...
				//发送包的目标mac地址与网卡地址对比
        } else if (s->phys[0] == buf[0] &&
                   s->phys[1] == buf[1] &&
                   s->phys[2] == buf[2] &&
                   s->phys[3] == buf[3] &&
                   s->phys[4] == buf[4] &&
                   s->phys[5] == buf[5]) {
            /* match */
            if (!(s->RxConfig & AcceptMyPhys))
            {
                DPRINTF(">>> rejecting physical address matching packet\n");

                /* update tally counter */
                ++s->tally_counters.RxERR;

                return size;
            }

           ...
        }
    }

    ...

    if (rtl8139_cp_receiver_enabled(s))
    {
        if (!rtl8139_cp_rx_valid(s)) {
            return size;
        }

        DPRINTF("in C+ Rx mode ================\n");

        ...

        int descriptor = s->currCPlusRxDesc;
        dma_addr_t cplus_rx_ring_desc;

        cplus_rx_ring_desc = rtl8139_addr64(s->RxRingAddrLO, s->RxRingAddrHI);
        cplus_rx_ring_desc += 16 * descriptor;

        DPRINTF("+++ C+ mode reading RX descriptor %d from host memory at "
            "%08x %08x = "DMA_ADDR_FMT"\n", descriptor, s->RxRingAddrHI,
            s->RxRingAddrLO, cplus_rx_ring_desc);

        uint32_t val, rxdw0,rxdw1,rxbufLO,rxbufHI;

        pci_dma_read(d, cplus_rx_ring_desc, &val, 4);
        rxdw0 = le32_to_cpu(val);
        pci_dma_read(d, cplus_rx_ring_desc+4, &val, 4);
        rxdw1 = le32_to_cpu(val);
        pci_dma_read(d, cplus_rx_ring_desc+8, &val, 4);
        rxbufLO = le32_to_cpu(val);
        pci_dma_read(d, cplus_rx_ring_desc+12, &val, 4);
        rxbufHI = le32_to_cpu(val);

        DPRINTF("+++ C+ mode RX descriptor %d %08x %08x %08x %08x\n",
            descriptor, rxdw0, rxdw1, rxbufLO, rxbufHI);

        if (!(rxdw0 & CP_RX_OWN))
        {
            ...
        }

        uint32_t rx_space = rxdw0 & CP_RX_BUFFER_SIZE_MASK;

        ...

        dma_addr_t rx_addr = rtl8139_addr64(rxbufLO, rxbufHI);

        /* receive/copy to target memory */
        if (dot1q_buf) {
            ...
        } else {
            pci_dma_write(d, rx_addr, buf, size);
        }

        ...
}
```

所以此处的漏洞原理大致就是：tx缓冲区中要发送的数据包，因为在发送的过程中并没有对ip->ip_len进行检测，导致了tcp的数据包长度超出了原有的长度，导致了信息泄露。而Tx标志位包含TxLoopBack时，会将数据包发送给自己的网卡，当发送的数据的mac地址为自身网卡且rx标志位包含AcceptAllPhys时会把相应的数据保存在Rx缓冲区中。

### 网卡执行流程

首先查看`pci_rtl8139_realize`函数

```c
static void pci_rtl8139_realize(PCIDevice *dev, Error **errp)
{
    RTL8139State *s = RTL8139(dev);
    DeviceState *d = DEVICE(dev);
    uint8_t *pci_conf;

    pci_conf = dev->config;
    pci_conf[PCI_INTERRUPT_PIN] = 1;    /* interrupt pin A */
    /* TODO: start of capability list, but no capability
     * list bit in status register, and offset 0xdc seems unused. */
    pci_conf[PCI_CAPABILITY_LIST] = 0xdc;
	// 注意此处的两个region_init_io
    memory_region_init_io(&s->bar_io, OBJECT(s), &rtl8139_io_ops, s,
                          "rtl8139", 0x100);
    memory_region_init_io(&s->bar_mem, OBJECT(s), &rtl8139_mmio_ops, s,
                          "rtl8139", 0x100);
    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->bar_io);
    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY, &s->bar_mem);

    qemu_macaddr_default_if_unset(&s->conf.macaddr);
	......
```

分别初始化了pmio和mmio，再来跟进

`rtl8139_io_ops`

```c
static const MemoryRegionOps rtl8139_io_ops = {
    .read = rtl8139_ioport_read,
    .write = rtl8139_ioport_write,
    .impl = {
        .min_access_size = 1,
        .max_access_size = 4,
    },
    .endianness = DEVICE_LITTLE_ENDIAN,
};

static uint64_t rtl8139_ioport_read(void *opaque, hwaddr addr,
                                    unsigned size)
{
    switch (size) {
    case 1:
        return rtl8139_io_readb(opaque, addr);
    case 2:
        return rtl8139_io_readw(opaque, addr);
    case 4:
        return rtl8139_io_readl(opaque, addr);
    }

    return -1;
}

static void rtl8139_ioport_write(void *opaque, hwaddr addr,
                                 uint64_t val, unsigned size)
{
    switch (size) {
    case 1:
        rtl8139_io_writeb(opaque, addr, val);
        break;
    case 2:
        rtl8139_io_writew(opaque, addr, val);
        break;
    case 4:
        rtl8139_io_writel(opaque, addr, val);
        break;
    }
}
```

`rtl8139_mmio_ops`

```c
static const MemoryRegionOps rtl8139_mmio_ops = {
    .old_mmio = {
        .read = {
            rtl8139_mmio_readb,
            rtl8139_mmio_readw,
            rtl8139_mmio_readl,
        },
        .write = {
            rtl8139_mmio_writeb,
            rtl8139_mmio_writew,
            rtl8139_mmio_writel,
        },
    },
    .endianness = DEVICE_LITTLE_ENDIAN,
};

static void rtl8139_mmio_writeb(void *opaque, hwaddr addr, uint32_t val)
{
    rtl8139_io_writeb(opaque, addr & 0xFF, val);
}

static void rtl8139_mmio_writew(void *opaque, hwaddr addr, uint32_t val)
{
    rtl8139_io_writew(opaque, addr & 0xFF, val);
}

static void rtl8139_mmio_writel(void *opaque, hwaddr addr, uint32_t val)
{
    rtl8139_io_writel(opaque, addr & 0xFF, val);
}

static uint32_t rtl8139_mmio_readb(void *opaque, hwaddr addr)
{
    return rtl8139_io_readb(opaque, addr & 0xFF);
}

static uint32_t rtl8139_mmio_readw(void *opaque, hwaddr addr)
{
    uint32_t val = rtl8139_io_readw(opaque, addr & 0xFF);
    return val;
}

static uint32_t rtl8139_mmio_readl(void *opaque, hwaddr addr)
{
    uint32_t val = rtl8139_io_readl(opaque, addr & 0xFF);
    return val;
}
```

可以看出，其实全是封装，最后都会来到这六个函数

```
rtl8139_io_readb , rtl8139_io_readw , rtl8139_io_readl
rtl8139_io_writeb , rtl8139_io_writew , rtl8139_io_writel
```

来看`rtl8139_io_writeb`

```c
static void rtl8139_io_writeb(void *opaque, uint8_t addr, uint32_t val)
{
    RTL8139State *s = opaque;

    switch (addr)
    {
        ......
        case TxThresh:
            DPRINTF("C+ TxThresh write(b) val=0x%02x\n", val);
            s->TxThresh = val;
            break;

        case TxPoll:
            DPRINTF("C+ TxPoll write(b) val=0x%02x\n", val);
            if (val & (1 << 7))
            {
                DPRINTF("C+ TxPoll high priority transmission (not "
                    "implemented)\n");
                //rtl8139_cplus_transmit(s);
            }
            if (val & (1 << 6))
            {
                DPRINTF("C+ TxPoll normal priority transmission\n");
                rtl8139_cplus_transmit(s);
            }

            break;

        default:
            DPRINTF("not implemented write(b) addr=0x%x val=0x%02x\n", addr,
                val);
            break;
    }
}
```

可以看到当val的二进制倒数第七位为1时，会调用`rtl8139_cplus_transmit`函数，`TxPoll`的功能为告诉网卡检查Tx缓冲区。

```c
static void rtl8139_cplus_transmit(RTL8139State *s)
{
    int txcount = 0;

    while (rtl8139_cplus_transmit_one(s))
    {
        ++txcount;
    }

    /* Mark transfer completed */
    if (!txcount)
    {
        DPRINTF("C+ mode : transmitter queue stalled, current TxDesc = %d\n",
            s->currCPlusTxDesc);
    }
    else
    {
        /* update interrupt status */
        s->IntrStatus |= TxOK;
        rtl8139_update_irq(s);
    }
}

```



### 漏洞利用

利用包含五个部分：

- 恶意网卡发送数据包的构造
- 网卡寄存器的配置
- 网卡发送缓冲区的配置
- 网卡接收缓冲区的配置
- 泄露信息的分析

1. 恶意网卡发送数据包的构造

   因为会判断mac地址与自身mac地址是否相等，所以需要将目的地址设置成网卡地址，此处可以获取到mac地址为 52:54:00:12:34:57

   ```shell
   enp0s4: flags=4098<BROADCAST,MULTICAST>  mtu 1500
           ether 52:54:00:12:34:57  txqueuelen 1000  (Ethernet)
           RX packets 0  bytes 0 (0.0 B)
           RX errors 0  dropped 0  overruns 0  frame 0
           TX packets 0  bytes 0 (0.0 B)
           TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
   
   ```

   还需要将类型设置为IP包，即0x0800

   IP数据包中需要构造的是16位总长度，`#define IP_HEADER_LENGTH(ip) (((ip->ip_ver_len)&0xf) << 2)`的长度为`5<<2`是20，因此需要构造`ip->ip_len`长度为`19(0x13)`，实现了漏洞构造`ip_data_len`为`0xffff`。

   tcp包就正常构造即可。

   最后的`packet`结构是：

   ```c
   uint8_t malformed_eth_packet[]={
       // 分别是6字节的目的地址和6字节的源地址，此处都是本身的网卡地址52:54:00:12:34:57
       0x52, 0x54, 0x00, 0x12, 0x34, 0x57, 0x52, 0x54, 0x00, 0x12, 0x34, 0x57, 
       // 两字节设置为IP包，也就是0x0800，接下来就是设置IP数据包格式，分别是4byte的版本和4byte的首部长度（这里是4和5），8byte的TOS（这里是00），16byte的总长度（这里是0x0013）（0x13 - (0x5 << 2) = 0xffff，导致溢出），2字节的id（这里是0xdead），2字节的片段偏移（这里是0x4000），1字节的ttl（这里是0x40），1字节的协议（这里是0x06，代表IP协议）
       0x08, 0x00, 0x45, 0x00, 0x00, 0x13, 0xde, 0xad, 0x40, 0x00, 0x40, 0x06, 
       // 两字节的首部校验和，32位（4字节）的源地址，32位的目的地址，接下来就是tcp数据包的内容，2字节的源端口号（0x0400）
       0xff, 0xff, 0x7f, 0x00, 0x00, 0x01, 0x7f, 0x00, 0x00, 0x01, 0x04, 0x00, 
       // 2字节的目的端口号（0x0400），4字节的序号，4字节的确认序号，2字节的长度（其中4byte的tcp首部长度）
       0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x10,
       // 2字节的窗口大小，2字节的校验和，2字节的紧急指针
       0x00, 0x00, 0xff, 0xff, 0x00, 0x00
           
   };
   ```

2. 网卡寄存器的配置

   因为漏洞的触发函数是`rtl8139_cplus_transmit_one`函数，为了能够成功触发漏洞与泄露信息，所以配置网卡
   
   1. 设置网卡`bChipCmdState`为`CmdTxEnb`以及`CmdRxEnb`
   
   ```c
   static int rtl8139_cplus_transmit_one(RTL8139State *s)
   {
       if (!rtl8139_transmitter_enabled(s))
       {
           DPRINTF("+++ C+ mode: transmitter disabled\n");
           return 0;
       }
       ......
   }
   static int rtl8139_transmitter_enabled(RTL8139State *s)
   {
       return s->bChipCmdState & CmdTxEnb;
   }
   
   static NetClientInfo net_rtl8139_info = {
       .type = NET_CLIENT_OPTIONS_KIND_NIC,
       .size = sizeof(NICState),
       .can_receive = rtl8139_can_receive, // 允许接收信息
       .receive = rtl8139_receive,
       .link_status_changed = rtl8139_set_link_status,
   };
   static int rtl8139_can_receive(NetClientState *nc)
   {
       RTL8139State *s = qemu_get_nic_opaque(nc);
       int avail;
   
       /* Receive (drop) packets if card is disabled.  */
       if (!s->clock_enabled)
         return 1;
       if (!rtl8139_receiver_enabled(s))
         return 1;
       ......
   }
   static int rtl8139_receiver_enabled(RTL8139State *s)
   {
       return s->bChipCmdState & CmdRxEnb;
   }
   ```
   
   2. 设置网卡`CpCmd`为`CPlusTxEnb`以及`CPlusRxEnb`
   
      ```c
      static int rtl8139_cplus_transmit_one(RTL8139State *s)
      {
          ......
          if (!rtl8139_cp_transmitter_enabled(s))
          {
              DPRINTF("+++ C+ mode: C+ transmitter disabled\n");
              return 0 ;
          }
          ......
      }
      static int rtl8139_cp_transmitter_enabled(RTL8139State *s)
      {
          return s->CpCmd & CPlusTxEnb;
      }
      
      static int rtl8139_can_receive(NetClientState *nc)
      {
          ......
      
          if (rtl8139_cp_receiver_enabled(s) && rtl8139_cp_rx_valid(s)) {
              /* ??? Flow control not implemented in c+ mode.
                 This is a hack to work around slirp deficiencies anyway.  */
              return 1;
          }
          ......
      }
      static int rtl8139_cp_receiver_enabled(RTL8139State *s)
      {
          return s->CpCmd & CPlusRxEnb;
      }
      ```
   
   3. 设置 txdw0
   
      ```c
      if (!(txdw0 & CP_TX_OWN))
      {......}
      if (txdw0 & CP_TX_FS)
      {......}
      if (txdw0 & CP_TX_LS)
          {
          	......
              if (txdw0 & (CP_TX_IPCS | CP_TX_UDPCS | CP_TX_TCPCS | CP_TX_LGSEN))
              {
                  ......
                  // 漏洞代码    
              }
      }
      if ((txdw0 & CP_TX_LGSEN) && ip_protocol == IP_PROTO_TCP)
      {	......
      	// 数据包分片代码
      }
      ```
   
      后续还有开启`transmitter`以及`receiver`，为了开启`cp_transmitter`以及`cp_receiver`，还需要配置`TxConfig`为`TxLoopBack `以及配置`RxConfig`为`AcceptMyPhys`。

### 信息处理

如果不对信息进行处理的话，那我们获取到的只是一堆无用数据。我们需要在这堆数据里面提取出qemu的基地址和qemu线程为虚拟机分配的起始地址

这里用到了`ObjectProperty`结构体，位置是qemu-2.3.0/include/qom/object.h。

```c
struct Object
{
    /*< private >*/
    ObjectClass *class;  //指向对应的类的数据结构的指针
    ObjectFree *free;    //当引用计数为0时调用
    GHashTable *properties;  //Object中的所有属性的hash表
    uint32_t ref;        //对象的引用计数
    Object *parent;      //指向父对象的指针
};
```

在qom对于封装的实现中，对于私有变量的实现是properties，它是一张hash表，这个变量包含了Object中的所有可访问和修改的数据、函数。这个Hash表中，每一个entry有对应的key和value，key是这个property的name，而value是一个ObjectProperty数据结构的指针，ObjectProperty是一个QEMU中的全局变量

```c
typedef struct ObjectProperty
{
    gchar *name;
    gchar *type;
    gchar *description;
    ObjectPropertyAccessor *get;
    ObjectPropertyAccessor *set;
    ObjectPropertyResolve *resolve;
    ObjectPropertyRelease *release;
    void *opaque;

    QTAILQ_ENTRY(ObjectProperty) node;
} ObjectProperty;
```

通过读取这个数据，并进行低12位的匹配，计算出qemu-system-x86-64的基地址，但是问题来了，很怪，找不到。然后获取到的物理地址，直接拿到了物理机里libc.so的地址，迷茫。