先来看snprintf函数

```c
#include <stdio.h>
 
int main () {
  char a[16];
  size_t i;
 
  i = snprintf(a, 13, "%012d", 12345);  // 第 1 种情况
  printf("i = %lu, a = %s\n", i, a);    // 输出：i = 12, a = 000000012345
 
  i = snprintf(a, 9, "%012d", 12345);   // 第 2 种情况
  printf("i = %lu, a = %s\n", i, a);    // 输出：i = 12, a = 00000001
 
  return 0;
}
```

可以看到：

1）如果格式化后的字符串长度 < size，则将此字符串全部复制到str中，并给其后添加一个字符串结束符('\0')；

2）如果格式化后的字符串长度 >= size，则只将其中的(size-1)个字符复制到str中，并给其后添加一个字符串结束符('\0')，返回值为**欲写入的字符串长度**

-----------------------------------------------------------------------------------------------------------------------------------------

**tcp网卡**

https://gitlab.freedesktop.org/slirp/libslirp/-/commit/68ccb8021a838066f0951d4b2817eb6b6f10a843

但是呢，在QEMU中，对于snprintf的调用都是建立在该函数能够返回真实写入的数据大小的基础上调用的，这就导致了如果你的数据长度超出了可允许写入的长度，但依然返回了你的数据长度，这里就导致了溢出的情况的出现。