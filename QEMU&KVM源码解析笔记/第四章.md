### cpu虚拟化介绍

intel在X86 CPU的基础上增加VMX架构来实现CPU的硬件虚拟化，VMX架构下有两类角色：虚拟机监视器（VMM）和虚拟机（VM）。VMM对整个系统的CPU和硬件有完全的控制权，它抽象出虚拟的CPU给各个VM，并能够将VM的CPU直接调度到物理CPU上运行。VM是一个虚拟机实例，能够支持操作系统以及各种软件栈和应用程序。

在QEMU中，QEMU/KVM是作为VMM，你挂载的虚拟机镜像作为VM。QEMU负责模拟整个电脑，构建对应架构，但是其中内存和CPU的虚拟化工作由KVM进行负责。

#### VMCS介绍

VMCS用来管理VMX non-root Operation的转换以及控制VCPU的行为。VMCS之于VCPU的作用类似于进程描述符之于进程的作用。

在VMCS的格式中，前8个字节是固定的，第一个4字节的第0位到第30位表示修正标识符，用来识别不同的VMCS版本，第一个4字节的第31位是shadow-VMCS indicator，VMM根据这个来判断是一个普通的VMCS还是shadow VMCS[^shadow]。VMCS的第二个4字节是VMX-abort indicator，当VM Exit发生错误时，会产生VMX-abort，导致处理器进入关闭，处理器写入一个非零值到VMX-abort indicator

[^shadow]: VMCS SHADOW允许硬件加速vmread，vmwrite指令，它允许VMM不拦截VMCS读/写的某些字段

VMCS数据区控制着VMX non-root和VMX root之间的转换，VMM通过VMREAD和VMWRITE指令在这里读写。一共6个数据区：

1. Guest-state区域，进行VM Entry时，虚拟机处理器的状态信息从这个区域加载，进行VM Exit的时候，虚拟机的当前状态信息写入到这个区域
2. Host-state区域，发生VM Exit的时候，需要切换到VMM的上下文运行，此时处理器的状态信息从这里加载
3. VM-execution控制区域，用来控制处理器在进入VM Entry之后的处理器行为
4. VM Exit控制区域，用来指定虚拟机在发生VM Exit时的行为，如一些寄存器的保存
5. VM Entry控制区域，指定虚拟机在发生VM Entry时的行为，如一些寄存器的加载
6. VM Exit信息区域，包含了最近产生的VM Exit信息，典型的信息包括退出的原因以及相应的数据

VCPU之间会共享物理CPU，VMM负责在多个VCPU之间分配物理CPU，每个VCPU都有自己的描述符，当VMM在切换VCPU运行时需要保存此时VCPU的状态。

### KVM模块初始化

KVM是基于内核的虚拟机监视器

KVM模块的初始化主要包括初始化CPU与架构无关的数据以及设置与架构有关的虚拟化支持。

VMM只有在CPU处于保护模式并且开启分页时才能进入VMX模式，以下是开启VMX模式需要做的事情：

1. 使用CPUID检测CPU是否支持VMX
2. 检测CPU支持VMX的能力，通过读写与VMX能力相关的MSR寄存器完成的
3. 分配一段4KB对齐的内存作为VMXON区域
4. 初始化VMXON区域的版本标识
5. 确保当前CPU运行模式的CR0寄存器符合进入VMX的条件，如CR0.PE = 1，CR0.PG = 1
6. 通过设置CR4.VMXE为1来开启VMX模式
7. 确保IA32_FEATURE_CONTROL寄存器被正确设置，其锁定位（0位）为1
8. 使用VMXON区域的物理地址作为操作数调用VMXON指令，执行完成后，如果RFLAGS.CF = 0则表示指令执行成功

KVM初始化既要配置好上述架构相关数据，也要完成架构无关部分，这部分由`kvm_init`完成

![image-20201019212350748](C:\Users\zhz\AppData\Roaming\Typora\typora-user-images\image-20201019212350748.png)

+ kvm_arch_init函数用来初始化架构相关代码，确保只有一个KVM实现能够加载到内核
+ kvm_irqfd_init初始化irqfd相关的数据，主要是创建一个线程
+ kvm_arch_hardware_setup创建一些跟启动KVM密切相关的数据结构以及初始化一些硬件特性
+ kvm_arch_check_processor_compat检测所有CPU的特性是否一致
+ 最后一个重要工作是创建一个Misc设备“/dev/kvm"
  - “/dev/kvm"的接口分为两类：一类为通用接口，如KVM_API_VERSION和KVM_CREATE_VM；另一类为架构相关接口。
  - KVM的ioctl处理整个KVM层面的请求

总结一下就是：KVM模块的初始化过程主要是对硬件进行检查，分配一些常用结构的缓存，创建一个“/dev/kvm"设备，得到vmcs的一个配置结构vmcs_config，并根据CPU特性设置一些全局变量，给每个物理CPU分配一个vmcs结构。注意，此时CPU还不在VMX模式下。因为即使创建了KVM模块，但是没有虚拟机的创建，那也就不必要让CPU进入VMX模式。

### 虚拟机的创建

从QEMU和KVM两个方向来考察KVM虚拟机的创建

#### QEMU

QEMU中使用KVMState结构体来表示KVM相关的数据结构。KVM_INIT函数首先打开”/dev/kvm"设备得到一个fd，并且会保存到类型为KVMState的变量s的成员fd中。调用ioctl(KVM_CREATE_VM)接口在KVM层面创建一个虚拟机

#### KVM

kvm_init最重要的作用就是调用“/dev/kvm"设备的ioclt(KVM_CREATE_VM)接口，在KVM模块中创建一台虚拟机。

`kvm_create_vm`是创建虚拟机的核心函数：

+ kvm_arch_alloc_vm分配一个KVM结构体，用来表示一台虚拟机
+ kvm_arch_init_vm初始化与架构相关的数据
+ hardware_enable_all来最终开启VMX模式，其主要调用hardware_enable函数，这函数设置CR4的VMXE位并且调用VMXON指令开启VMX
+ kvm_alloc_memslots为虚拟机分配内存槽[^1]
+ 为KVM结构体中类型为kvm_io_bus的成员buses分配空间，其作用是将内核中实现的模拟设备连接起来

[^1]: [内存](https://baike.baidu.com/item/内存)插槽是指[主板](https://baike.baidu.com/item/主板/104636)上用来插[内存](https://baike.baidu.com/item/内存)条的插槽

### CPU的创建

