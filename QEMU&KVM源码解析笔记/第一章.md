# QEMU/KVM概述

## 虚拟机简介

**模拟器**是另一种形式的虚拟机，它可以视为一种硬件指令集（ISA），应用程序在源ISA上被编译出来，在模拟器帮助下，运行在不同的目标ISA上。简单来说，就是将所有源ISA指令翻译成目标ISA上的指令，如下图所示。

![image-20200918201739913](https://gitee.com/zhzzhz/blog_warehouse/raw/master/img/image-20200918201739913.png)

**高级语言虚拟机**则更进一步，将**源ISA**和**目标ISA**完全分离开，虚拟机中并无任何具体物理ISA指令字节，而是自己定义虚拟的指令字节，这些指令字节通常叫**字节码**。虚拟机的作用就是将这种自定义的虚拟的指令字节转换成**对应平台的物理ISA指令**。

系统虚拟化中，管理全局物理资源的软件叫做虚拟机监视器（VMM），其之于虚拟机就如同操作系统之于进程。

## QEME/KVM架构

QMEU-KVM：最开始KVM只负责最核心的CPU虚拟化和内存虚拟化部分，QEMU作为其用户态组件，负责完成大量外设的模拟。

CPU引入了支持硬件虚拟化的指令集VT-x之后出现了VMX root 和 VMX non-root。VMX root理解成宿主机模式，VMX non-root理解成虚拟机模式。

CPU在运行包括QEMU在内的普通进程和宿主机的操作系统内核时，处于VMX root模式，CPU在运行虚拟机中的用户程序和操作系统代码时处于VMX non-root模式。

### QEMU的主要任务

创建模拟芯片组。创建CPU线程表示虚拟机的CPU执行流，在QEMU的虚拟地址空间中分配空间作为虚拟机的物理地址，还需要针对用户在命令行指定的设备创建对应的虚拟设备

虚拟机的虚拟地址到宿主机物理地址转换流程：

1. 通过虚拟机中的操作系统页表，实现虚拟机虚拟地址到虚拟机物理地址的转换
2. 通过KVM的页表，实现虚拟机物理地址到宿主机物理地址的转换

### CPU虚拟化

QEMU创建CPU线程，在初始化的时候设置好相应的虚拟CPU寄存器的值，然后调用KVM的接口，运行虚拟机，在物理CPU上执行虚拟机代码。

在虚拟机运行时，KVM会截获虚拟机中的敏感指令，当虚拟机中的代码是敏感指令或者满足了一定的退出条件时，CPU会从VMX non-root模式退出到KVM，这就是下图的VM exit。虚拟机的退出首先陷入到KVM进行处理，但是如果遇到KVM无法处理的事件，比如虚拟机写了设备的寄存器地址，那么KVM就会将这个操作交给QEMU处理。当QEMU/KVM处理好了退出事件后，又会将CPU置于VMX non-root模式，也就是下图的VM Entry。

KVM使用VMCS结构来保存VM Exit和VM Entry

![image-20200918220104834](https://gitee.com/zhzzhz/blog_warehouse/raw/master/img/image-20200918220104834.png)

### 内存虚拟化

QEMU初始化时调用KVM接口告知KVM，虚拟机所需要的物理内存，通过mmap分配宿主机的虚拟内存空间作为虚拟机的物理内存，QEMU在更新内存布局时会持续调用KVM通知内核KVM模块虚拟机的内存分布。

在CPU支持EPT（拓展页表）后，CPU会自动完成**虚拟机物理地址**到**宿主机物理地址**的转换。虚拟机第一次访问内存的时候会陷入KVM，KVM逐渐建立起EPT页面。这样后续的虚拟机的虚拟CPU访问虚拟机**虚拟内存地址**时，会先被转换为**虚拟机物理地址**，接着查找EPT表，获取宿主机物理地址

![image-20200918222909167](https://gitee.com/zhzzhz/blog_warehouse/raw/master/img/image-20200918222909167.png)

### 虚拟机创建过程

```c
第一步，获取到kvm句柄
kvmfd = open("/dev/kvm", O_RDWR);
// 获取kvm的版本号，从而使应用层知道相关接口在内核是否有支持
ioctl (kvmfd, KVM_GET_API_VERSION,NULL);
第二步，创建虚拟机，获取到虚拟机句柄。
vmfd = ioctl(kvmfd, KVM_CREATE_VM, 0);
第三步，为虚拟机映射内存，还有其他的PCI，信号处理的初始化。
ioctl(kvmfd, KVM_SET_USER_MEMORY_REGION, &mem);
第四步，将虚拟机镜像映射到内存，相当于物理机的boot过程，把镜像映射到内存。
第五步，创建vCPU，并为vCPU分配内存空间。每一个vcpu都有一个struct_kvm_run结构，用来在用户态（qemu）和内核态（KVM）共享数据。
ioctl(kvmfd, KVM_CREATE_VCPU, vcpuid);
// 用户态程序需要将这段空间映射到用户空间，调用ioctl(KVM_GET_VCPU_MMAP_SIZE)得到这个结构大小
vcpu->kvm_run_mmap_size = ioctl(kvm->dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0);
第五步，创建vCPU个数的线程并运行虚拟机。
ioctl(kvm->vcpus->vcpu_fd, KVM_RUN, 0);
第六步，线程进入循环，并捕获虚拟机退出原因，做相应的处理。
这里的退出并不一定是虚拟机关机，虚拟机如果遇到IO操作，访问硬件设备，缺页中断等都会退出执行，退出执行可以理解为将CPU执行上下文返回到QEMU。如果内核态的KVM不能处理就会交给应用层软件处理
```

