此处以QEMU1.3.0的源码架构为例

docs/ 包含了一些文档，说实话，对初学者来说，读这些文档压根没有头绪

hw/  包含了所有支持的硬件设备
include/ 包含了一些头文件
linux-user/ 包含了linux下的用户模式的代码
target-XXX/  包含了QEMU目前所支持guset端的处理器架构。包括：alpha,arm,cris,i386,lm32,m68k,microblaze,mips,openrisc,ppc,s390x,sh4,sparc,unicore32,xtensa. 此处的XXX就是指这其中的一种架构。包含的代码的主要功能是将该guest架构的指令翻译成TCG OP代码。也就是target-arm下的代码就是将arm架构的指令翻译成TCG OP。这些目录占了源码目录的很大一部分。
tcg/  包含了动态翻译工具tcg的源码部分，主要是将TCG OP转化为host binary的部分。这个目录下也包含了多个架构名字命名的目录，每个目录下存放着针对该架构的代码。后续会详细介绍。
test/ 从名字上可以看出，应该是存放测试部分的代码，但是目前这部分代码还没读。



QEMU的主要功能就是不断提取客户机代码并且转化成主机指定架构的代码。整个翻译任务分为两个部分：第一个部分是将做目标代码（TB）转化成TCG中间代码，然后再将中间代码转化成主机代码。

第一部分，中间代码转化的过程，相当于反汇编

第二部分，转化成对应架构主机代码的过程，相当于后端编译器，但是现在是作为一个动态翻译器来使用

### 1. 开始执行：

主要比较重要的c文件有：/vl.c,/cpus.c, /exec-all.c, /exec.c, /cpu-exec.c.这几个文件进行重点

vl.c文件这个函数的功能主要是建立一个虚拟的硬件环境。它通过参数的解析，将初始化内存，需要的模拟的设备初始化，CPU参数，初始化KVM

然后跳转到/cpus.c, /exec-all.c, /exec.c, /cpu-exec.c

### 2. 硬件模拟

hw文件夹，这个重点攻克

所有的设备都有独自的文件，包括总线，串口，网卡，鼠标等等。它们通过设备模块串在一起，在vl.c中的machine _init中初始化。

### 3.目标机器

上面的第一部分，将宿主机的真实cpu架构下的代码转化为中间代码，源码位置在qemu source code/target-XXX。此处的XXX指的是模拟出来的系统的架构。

### 4.主机

上面的第二部分，将中间代码转化为要模拟的架构的对应代码。源码的位置是：qemu source code/tcg

### 总流程

/vl.c:                   最主要的模拟循环，虚拟机机器环境初始化，和CPU的执行。

/target-arch/translate.c  将客户机代码转化成不同架构的TCG操作码。

/tcg/tcg.c               主要的TCG代码。

/tcg/arch/tcg-target.c     将TCG代码转化生成主机代码

/cpu-exec.c             其中的cpu-exec()函数主要寻找下一个TB（翻译代码块），如果没找到就请求得到下一个TB，并且操作生成的代码块。