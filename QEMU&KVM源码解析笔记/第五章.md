### 内存虚拟化

MMU虚拟化：当虚拟机中的虚拟CPU进行内存寻址的时候，要想访问到实际的物理地址，需要经历以下步骤，虚拟机内部的虚拟地址-->虚拟机内部的物理地址-->QEMU线程的虚拟地址-->物理机上的物理地址。

EPT方案：MMU虚拟化的具体实现方案，其CPU寻址方式在VM non-root operation下会发生变化，使用两个页表，分别是虚拟机页表（从虚拟机虚拟地址转换到虚拟机物理地址）和EPT页表（从虚拟机物理地址转换到宿主机物理地址）。

​	注：开启EPT，当CPU进行VM Entry时，会使用EPT功能；当CPU产生VM Exit时，EPT会关闭，此		   时CPU在宿主机上会按传统的单页表寻址方式

EPT寻址方式：

EPT共48位物理地址，四级页表每页表使用9位物理地址（页表内部的offset）和一个页内的偏移（12位）

![image-20201026204314480](https://gitee.com/zhzzhz/blog_warehouse/raw/master/img/image-20201026204314480.png)

#### QEMU内存初始化的基本结构

`AddressSpace`结构体：表示一个虚拟机或者虚拟CPU能够访问的所有物理地址（这里指的是寻址地址）

```c
 struct AddressSpace {
     /* private: */
     struct rcu_head rcu;
     char *name;
     MemoryRegion *root;  // 表示对应的一个根MemoryRegion
 
     /* Accessed via RCU.  */
     struct FlatView *current_map; // 该地址空间是平坦模式下的一个视图
 
     int ioeventfd_nb;
     struct MemoryRegionIoeventfd *ioeventfds;
     QTAILQ_HEAD(, MemoryListener) listeners;
     QTAILQ_ENTRY(AddressSpace) address_spaces_link;
 };
```

> IA-32处理器平台允许3种不同的访问系统内存的方法：
>
> （1）平坦内存模式
>
> （2）分段内存模式
>
> （3）实地址模式
>
> 平坦内存模式把全部系统内存表示为连续的地址空间。所有指令、数据和堆栈都包含在相同的地址空间中。通过称为线性地址（linear address）的特定地址访问每个内存位置。
>
> 分段内存模式把系统内存划分为独立段的组，通过位于段寄存器中的指针进行引用。每个段用于包含特定类型的数据。一个段用于包含指令码，另一个段用于包含数据元素，第三个段用于包含程序堆栈。
>
> 段中的内存位置是通过逻辑地址定义的。逻辑地址由段地址（存放在段寄存器中）和偏移地址构成。处理器把逻辑地址转换为相应的线性地址位置以便访问内存的字节。
>
> 如果程序使用实地址模式，那么所有段寄存器都指向零线性地址，并且不会被程序改动。所有指令码、数据元素、堆栈元素都是通过它们的线性地址直接访问的。

`MemoryRegion`结构体：表示虚拟机的一段内存区域

```c
struct MemoryRegion {
     Object parent_obj;
 
     /* private: */
 
     /* The following fields should fit in a cache line */
     bool romd_mode;
     bool ram;
     bool subpage;
     bool readonly; /* For RAM regions */
     bool nonvolatile;
     bool rom_device;
     bool flush_coalesced_mmio;
     bool global_locking;
     uint8_t dirty_log_mask;
     bool is_iommu;
     RAMBlock *ram_block;  // 实际分配的物理内存
     Object *owner;
 
     const MemoryRegionOps *ops; // 回调函数，例如MMIO的read，write
     void *opaque;
     MemoryRegion *container; // 表示该MemoryRegion所处的上一级MemoryRegion
     Int128 size;
     hwaddr addr; // MemoryRegion所在的虚拟机的物理地址
     void (*destructor)(MemoryRegion *mr);
     uint64_t align;
     bool terminates; // 是否是叶子节点
     bool ram_device;
     bool enabled;
     bool warning_printed; /* For reservations */
     uint8_t vga_logging_count;
     MemoryRegion *alias;
     hwaddr alias_offset;
     int32_t priority; // MemoryRegion的优先级
     QTAILQ_HEAD(, MemoryRegion) subregions;
     QTAILQ_ENTRY(MemoryRegion) subregions_link;
     QTAILQ_HEAD(, CoalescedMemoryRange) coalesced;
     const char *name;
     unsigned ioeventfd_nb;
     MemoryRegionIoeventfd *ioeventfds;
 };
```

常见的MemoryRegion有如下几类：

1. RAM：host上一段实际分配给虚拟机作为物理内存的虚拟内存
2. MMIO：guest的一段内存，但在宿主机上没有对应的虚拟内存，而是截获对这个区域的访问，调用对应读写函数用在设备模拟中
3. ROM：与RAM类似，但这类型内存是只读
4. ROM device：在读方面类似RAM，能直接读取，写方面类似MMIO，写入会调用对应的回调函数
5. container：包含若干个MemoryRegion，每一个Region在这个container的偏移都不一样。container主要将多个MemoryRegion合并成一个，例如PCI的MemoryRegion包括RAM和MMIO。
6. alias：region的另一个部分，可以使一个region被分成几个不连续的部分。

#### QEMU虚拟机内存初始化

内存分为低端内存和高端内存：

+ 如果用户在命令行指定了max-ram-below-4g参数，则使用用户指定的参数，这可以让一些非传统的虚拟机使用更多的4GB以下的地址空间

+ 如果用户没有指定max-ram-below-4g参数，则分两种情况：
  1. 传统的虚拟机（qemu-2.5以下）使用3.5GB（0xe0000000）作为分界线
  2. 高版本虚拟机会设置gigabyte_align，当虚拟机的内存大于传统低端内存（3.5GB）时，会以3GB作为分界线。超过lowmem的地址就是高端内存了。

`cpu_exec_init_all`进行初始化操作，其中的`io_mem_init`创建若干个包含所有地址空间的MemoryRegion，`memory_map_init`创建`address_space_memory`(虚拟机的内存地址空间)和`address_space_io`(I/O地址空间)

`pc_initl`函数与虚拟机内存虚拟化有关的部分：创建一个PCI地址空间pci_memory

+ 调用pc_memory_init函数进行内存初始化

  ```c
  FWCfgState *pc_memory_init(MachineState *machine,
                             MemoryRegion *system_memory,
                             ram_addr_t below_4g_mem_size,
                             ram_addr_t above_4g_mem_size,
                             MemoryRegion *rom_memory,
                             MemoryRegion **ram_memory,
                             PcGuestInfo *guest_info)
  {
      ......
      ram = g_malloc(sizeof(*ram));
      // 分配虚拟机的实际物理内存，name = "pc.ram"
      memory_region_allocate_system_memory(ram, NULL, "pc.ram",
                                           machine->ram_size);
      *ram_memory = ram;
      ram_below_4g = g_malloc(sizeof(*ram_below_4g));
      // 创建一个ram_below_4g region
      memory_region_init_alias(ram_below_4g, NULL, "ram-below-4g", ram,
                               0, below_4g_mem_size);
      // 将ram_below_4g设置为pc.ram子ragion
      memory_region_add_subregion(system_memory, 0, ram_below_4g);
      // 将小于4GB的内存加入到/etc/e820表中供BIOS使用
      e820_add_entry(0, below_4g_mem_size, E820_RAM);
      if (above_4g_mem_size > 0) {
          ram_above_4g = g_malloc(sizeof(*ram_above_4g));
          memory_region_init_alias(ram_above_4g, NULL, "ram-above-4g", ram,
                                   below_4g_mem_size, above_4g_mem_size);
          memory_region_add_subregion(system_memory, 0x100000000ULL,
                                      ram_above_4g);
          e820_add_entry(0x100000000ULL, above_4g_mem_size, E820_RAM);
      }
  
      ......
  
      /* Initialize PC system firmware */
      pc_system_firmware_init(rom_memory, guest_info->isapc_ram_fw);
  
      option_rom_mr = g_malloc(sizeof(*option_rom_mr));
      memory_region_init_ram(option_rom_mr, NULL, "pc.rom", PC_ROM_SIZE,
                             &error_abort);
      vmstate_register_ram_global(option_rom_mr);
      memory_region_add_subregion_overlap(rom_memory,
                                          PC_ROM_MIN_VGA,
                                          option_rom_mr,
                                          1);
  	// 创建fw_cfg设备
      fw_cfg = bochs_bios_init();
      // 将fw_cfg设备复制到全局变量fw_cfg中
      rom_set_fw(fw_cfg);
  
      if (guest_info->has_reserved_memory && pcms->hotplug_memory_base) {
          uint64_t *val = g_malloc(sizeof(*val));
          *val = cpu_to_le64(ROUND_UP(pcms->hotplug_memory_base, 0x1ULL << 30));
          fw_cfg_add_file(fw_cfg, "etc/reserved-memory-end", val, sizeof(*val));
      }
  
      if (linux_boot) {
          load_linux(fw_cfg, machine->kernel_filename, machine->initrd_filename,
                     machine->kernel_cmdline, below_4g_mem_size);
      }
  
      for (i = 0; i < nb_option_roms; i++) {
          rom_add_option(option_rom[i].name, option_rom[i].bootindex);
      }
      guest_info->fw_cfg = fw_cfg;
      return fw_cfg;
  }
  ```

#### 分配虚拟机RAM过程

RAM通过`memory_region_allocate_system_memory`函数分配，`allocate_system_memory_nonnuma`->`memory_region_init_ram`->`qemu_ram_alloc`

```c
void memory_region_allocate_system_memory(MemoryRegion *mr, Object *owner,
                                          const char *name,
                                          uint64_t ram_size)
{
    uint64_t addr = 0;
    int i;

    if (nb_numa_nodes == 0 || !have_memdevs) {
        allocate_system_memory_nonnuma(mr, owner, name, ram_size);
        return;
    }
	......
}

static void allocate_system_memory_nonnuma(MemoryRegion *mr, Object *owner,
                                           const char *name,
                                           uint64_t ram_size)
{
    if (mem_path) {
		......
    } else {
        memory_region_init_ram(mr, owner, name, ram_size, &error_abort);
    }
    vmstate_register_ram_global(mr);
}

void memory_region_init_ram(MemoryRegion *mr,
                            Object *owner,
                            const char *name,
                            uint64_t size,
                            Error **errp)
{
    memory_region_init(mr, owner, name, size);
    mr->ram = true;
    mr->terminates = true;
    mr->destructor = memory_region_destructor_ram;
    mr->ram_addr = qemu_ram_alloc(size, mr, errp); // 分配一个RAMBlock结构以及虚拟机物理内存对应的QEMU进程中的虚拟内存
}
```

RAMBlock结构体表示的是虚拟机中的一块内存条，里面记录了内存条的一些基本信息